// Code generated by sails-client-gen. DO NOT EDIT.
#[allow(unused_imports)]
use sails_rs::collections::BTreeMap;
#[allow(unused_imports)]
use sails_rs::{
    calls::{Activation, Call, Query, Remoting, RemotingAction},
    prelude::*,
    String,
};
pub struct TransferFactory<R> {
    #[allow(dead_code)]
    remoting: R,
}
impl<R> TransferFactory<R> {
    #[allow(unused)]
    pub fn new(remoting: R) -> Self {
        Self { remoting }
    }
}
impl<R: Remoting + Clone> traits::TransferFactory for TransferFactory<R> {
    type Args = R::Args;
    fn new(&self) -> impl Activation<Args = R::Args> {
        RemotingAction::<_, transfer_factory::io::New>::new(self.remoting.clone(), ())
    }
}
pub mod transfer_factory {
    use super::*;
    pub mod io {
        use super::*;
        use sails_rs::calls::ActionIo;
        pub struct New(());
        impl New {
            #[allow(dead_code)]
            pub fn encode_call() -> Vec<u8> {
                <New as ActionIo>::encode_call(&())
            }
        }
        impl ActionIo for New {
            const ROUTE: &'static [u8] = &[12, 78, 101, 119];
            type Params = ();
            type Reply = ();
        }
    }
}
pub struct TransferCall<R> {
    remoting: R,
}
impl<R> TransferCall<R> {
    pub fn new(remoting: R) -> Self {
        Self { remoting }
    }
}
impl<R: Remoting + Clone> traits::TransferCall for TransferCall<R> {
    type Args = R::Args;
    fn create_vft(
        &mut self,
        code_id: CodeId,
        name: String,
        symbol: String,
        decimals: u8,
    ) -> impl Call<Output = bool, Args = R::Args> {
        RemotingAction::<_, transfer_call::io::CreateVft>::new(
            self.remoting.clone(),
            (code_id, name, symbol, decimals),
        )
    }
    fn transfer(
        &mut self,
        token: ActorId,
        to: ActorId,
        value: U256,
    ) -> impl Call<Output = bool, Args = R::Args> {
        RemotingAction::<_, transfer_call::io::Transfer>::new(
            self.remoting.clone(),
            (token, to, value),
        )
    }
    fn transfer_from(
        &mut self,
        token: ActorId,
        from: ActorId,
        to: ActorId,
        value: U256,
    ) -> impl Call<Output = bool, Args = R::Args> {
        RemotingAction::<_, transfer_call::io::TransferFrom>::new(
            self.remoting.clone(),
            (token, from, to, value),
        )
    }
    fn get_balance_from_contract(
        &self,
        owner: ActorId,
        token: ActorId,
    ) -> impl Query<Output = U256, Args = R::Args> {
        RemotingAction::<_, transfer_call::io::GetBalanceFromContract>::new(
            self.remoting.clone(),
            (owner, token),
        )
    }
}
pub mod transfer_call {
    use super::*;
    pub mod io {
        use super::*;
        use sails_rs::calls::ActionIo;
        pub struct CreateVft(());
        impl CreateVft {
            #[allow(dead_code)]
            pub fn encode_call(
                code_id: CodeId,
                name: String,
                symbol: String,
                decimals: u8,
            ) -> Vec<u8> {
                <CreateVft as ActionIo>::encode_call(&(code_id, name, symbol, decimals))
            }
        }
        impl ActionIo for CreateVft {
            const ROUTE: &'static [u8] = &[
                48, 84, 114, 97, 110, 115, 102, 101, 114, 67, 97, 108, 108, 36, 67, 114, 101, 97,
                116, 101, 86, 102, 116,
            ];
            type Params = (CodeId, String, String, u8);
            type Reply = bool;
        }
        pub struct Transfer(());
        impl Transfer {
            #[allow(dead_code)]
            pub fn encode_call(token: ActorId, to: ActorId, value: U256) -> Vec<u8> {
                <Transfer as ActionIo>::encode_call(&(token, to, value))
            }
        }
        impl ActionIo for Transfer {
            const ROUTE: &'static [u8] = &[
                48, 84, 114, 97, 110, 115, 102, 101, 114, 67, 97, 108, 108, 32, 84, 114, 97, 110,
                115, 102, 101, 114,
            ];
            type Params = (ActorId, ActorId, U256);
            type Reply = bool;
        }
        pub struct TransferFrom(());
        impl TransferFrom {
            #[allow(dead_code)]
            pub fn encode_call(token: ActorId, from: ActorId, to: ActorId, value: U256) -> Vec<u8> {
                <TransferFrom as ActionIo>::encode_call(&(token, from, to, value))
            }
        }
        impl ActionIo for TransferFrom {
            const ROUTE: &'static [u8] = &[
                48, 84, 114, 97, 110, 115, 102, 101, 114, 67, 97, 108, 108, 48, 84, 114, 97, 110,
                115, 102, 101, 114, 70, 114, 111, 109,
            ];
            type Params = (ActorId, ActorId, ActorId, U256);
            type Reply = bool;
        }
        pub struct GetBalanceFromContract(());
        impl GetBalanceFromContract {
            #[allow(dead_code)]
            pub fn encode_call(owner: ActorId, token: ActorId) -> Vec<u8> {
                <GetBalanceFromContract as ActionIo>::encode_call(&(owner, token))
            }
        }
        impl ActionIo for GetBalanceFromContract {
            const ROUTE: &'static [u8] = &[
                48, 84, 114, 97, 110, 115, 102, 101, 114, 67, 97, 108, 108, 88, 71, 101, 116, 66,
                97, 108, 97, 110, 99, 101, 70, 114, 111, 109, 67, 111, 110, 116, 114, 97, 99, 116,
            ];
            type Params = (ActorId, ActorId);
            type Reply = U256;
        }
    }
    #[allow(dead_code)]
    #[cfg(not(target_arch = "wasm32"))]
    pub mod events {
        use super::*;
        use sails_rs::events::*;
        #[derive(PartialEq, Debug, Encode, Decode)]
        #[codec(crate = sails_rs::scale_codec)]
        pub enum TransferCallEvents {
            Transfer {
                vft: ActorId,
                from: ActorId,
                to: ActorId,
                value: U256,
            },
            VftCreated {
                vft: ActorId,
                name: String,
                symbol: String,
                decimals: u8,
            },
        }
        impl EventIo for TransferCallEvents {
            const ROUTE: &'static [u8] =
                &[48, 84, 114, 97, 110, 115, 102, 101, 114, 67, 97, 108, 108];
            const EVENT_NAMES: &'static [&'static [u8]] = &[
                &[32, 84, 114, 97, 110, 115, 102, 101, 114],
                &[40, 86, 102, 116, 67, 114, 101, 97, 116, 101, 100],
            ];
            type Event = Self;
        }
        pub fn listener<R: Listener<Vec<u8>>>(remoting: R) -> impl Listener<TransferCallEvents> {
            RemotingListener::<_, TransferCallEvents>::new(remoting)
        }
    }
}
pub mod traits {
    use super::*;
    #[allow(dead_code)]
    pub trait TransferFactory {
        type Args;
        #[allow(clippy::new_ret_no_self)]
        #[allow(clippy::wrong_self_convention)]
        fn new(&self) -> impl Activation<Args = Self::Args>;
    }
    #[allow(clippy::type_complexity)]
    pub trait TransferCall {
        type Args;
        fn create_vft(
            &mut self,
            code_id: CodeId,
            name: String,
            symbol: String,
            decimals: u8,
        ) -> impl Call<Output = bool, Args = Self::Args>;
        fn transfer(
            &mut self,
            token: ActorId,
            to: ActorId,
            value: U256,
        ) -> impl Call<Output = bool, Args = Self::Args>;
        fn transfer_from(
            &mut self,
            token: ActorId,
            from: ActorId,
            to: ActorId,
            value: U256,
        ) -> impl Call<Output = bool, Args = Self::Args>;
        fn get_balance_from_contract(
            &self,
            owner: ActorId,
            token: ActorId,
        ) -> impl Query<Output = U256, Args = Self::Args>;
    }
}
#[cfg(feature = "with_mocks")]
#[cfg(not(target_arch = "wasm32"))]
extern crate std;
#[cfg(feature = "with_mocks")]
#[cfg(not(target_arch = "wasm32"))]
pub mod mockall {
    use super::*;
    use sails_rs::mockall::*;
    mock! { pub TransferCall<A> {} #[allow(refining_impl_trait)] #[allow(clippy::type_complexity)] impl<A> traits::TransferCall for TransferCall<A> { type Args = A; fn create_vft (&mut self, code_id: CodeId,name: String,symbol: String,decimals: u8,) -> MockCall<A, bool>;fn transfer (&mut self, token: ActorId,to: ActorId,value: U256,) -> MockCall<A, bool>;fn transfer_from (&mut self, token: ActorId,from: ActorId,to: ActorId,value: U256,) -> MockCall<A, bool>;fn get_balance_from_contract (& self, owner: ActorId,token: ActorId,) -> MockQuery<A, U256>; } }
}
